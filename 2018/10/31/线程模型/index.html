<!DOCTYPE html>



  


<html class="theme-next muse use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/new_favicon_source_02_180x180.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/1571293259.jpg?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/1571293259.jpg?v=5.1.4">


  <link rel="mask-icon" href="/images/new_favicon_source_02.jpg?v=5.1.4" color="#222">





  <meta name="keywords" content="Java," />










<meta name="description" content="线程模型分享 （上）本篇文章是公司大佬约拿上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。">
<meta name="keywords" content="Java">
<meta property="og:type" content="article">
<meta property="og:title" content="线程模型">
<meta property="og:url" content="http://yoursite.com/2018/10/31/线程模型/index.html">
<meta property="og:site_name" content="LiuBo&#39;s Notes">
<meta property="og:description" content="线程模型分享 （上）本篇文章是公司大佬约拿上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。">
<meta property="og:locale" content="zh-Hans">
<meta property="og:image" content="https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png">
<meta property="og:image" content="https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png">
<meta property="og:image" content="https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png">
<meta property="og:updated_time" content="2019-08-26T07:54:42.995Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="线程模型">
<meta name="twitter:description" content="线程模型分享 （上）本篇文章是公司大佬约拿上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。">
<meta name="twitter:image" content="https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":true,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2018/10/31/线程模型/"/>





  <title>线程模型 | LiuBo's Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">LiuBo's Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2018/10/31/线程模型/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="xlbpowder">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/new_favicon_source_02_180x180.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="LiuBo's Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">线程模型</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-10-31T10:00:00+08:00">
                2018-10-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Java/" itemprop="url" rel="index">
                    <span itemprop="name">Java</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          
            <span class="post-meta-divider">|</span>
            <span class="page-pv"><i class="fa fa-file-o"></i>  阅读数
            <span class="busuanzi-value" id="busuanzi_value_page_pv" ></span>
            </span>
          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="线程模型分享-（上）"><a href="#线程模型分享-（上）" class="headerlink" title="线程模型分享 （上）"></a>线程模型分享 （上）</h1><p>本篇文章是公司大佬<strong>约拿</strong>上周五给我培训的文档，分享给大家。非常感谢百忙之中给我培训。</p>
<a id="more"></a>
<h2 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h2><blockquote>
<p>为什么有这篇文章？</p>
</blockquote>
<p>起先看我的目标是看netty的线程模型，但是在看netty的过程中，我发现很多知识点是互相关联的。比如netty的EventLoop，EventLoopGroup其实是继承自JDK的线程池。学习netty的线程模型前需要懂得预备知识。基于这个理由，我把预备内容部分也写下来。分享一共会分为上下两篇，这里是第上篇，这篇主要是先导，给【下篇】的知识打基础，有了上篇的基础再看下篇就容易多了。</p>
<blockquote>
<p>这篇文章会有什么内容？</p>
<ul>
<li>JDK线程池的类继承层次</li>
<li>构建线程池的几个核心要素</li>
<li>JDK线程池关键方法的分析</li>
<li>JDK线程池存在的问题</li>
<li>常见的线程模型举例</li>
<li>线程模型适用场景分析 </li>
<li>线程竞争与锁</li>
</ul>
</blockquote>
<blockquote>
<p>文章目的</p>
<ul>
<li>可以自定义JDK线程池，了解JDK线程池的局限场景</li>
<li>了解线程模型的原理及适用场景</li>
<li>了解锁的目的及分类</li>
</ul>
</blockquote>
<h2 id="线程启动与停止"><a href="#线程启动与停止" class="headerlink" title="线程启动与停止"></a>线程启动与停止</h2><blockquote>
<p>如何启动线程</p>
</blockquote>
<p>这个比较基础的不说了</p>
<blockquote>
<p>如何停止线程</p>
</blockquote>
<ol>
<li>线程类有stop，suspend方法，但是被弃用了。</li>
</ol>
<ul>
<li><strong>stop</strong> 会立即杀死线程，可能导致执行一半的程序被终结导致数据不一致的风险</li>
<li><strong>suspend</strong> 会挂起线程，但是不会释放锁，可能会造成死锁</li>
<li>线程池有个 <strong>shutdown</strong> 方法只是阻止线程池接受新的线程 ，并不会停止已存在的线程。</li>
</ul>
<ol start="2">
<li>正确的方法</li>
</ol>
<ul>
<li>线程自己运行完成</li>
<li>设置终止标志，在循环中检查这个标志</li>
</ul>
<h2 id="JDK线程池继承层次"><a href="#JDK线程池继承层次" class="headerlink" title="JDK线程池继承层次"></a>JDK线程池继承层次</h2><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://user-images.githubusercontent.com/5201798/47539254-f5648380-d901-11e8-9446-8a4705430539.png" alt="image"></p>
<p>这个图上很多类不用看，因为都是Executors类的内部类，代理类，核心就是下图的几个接口和类。</p>
<p><img src="https://user-images.githubusercontent.com/5201798/47539187-a74f8000-d901-11e8-9f94-f8f4be0477a0.png" alt="image"></p>
<h3 id="线程池核心要素"><a href="#线程池核心要素" class="headerlink" title="线程池核心要素"></a>线程池核心要素</h3><ul>
<li><p>核心线程池大小 corePoolSize</p>
<blockquote>
<p>设置一个线程池中的核心线程数 如果设置allowCoreThreadTimeOut为false的情况下： 即使当线程池中的线程处于空闲状态，这些线程也不会被线程池中移除。 如果设置了allowCoreThreadTimeOut为true, 那么当核心线程在空闲了一段时间后依旧没有用于工作，那么将会从线程池中移除。 注意:(allowCoreThreadTimeOut默认为false，通常情况下也无需做修改)</p>
</blockquote>
</li>
<li><p>线程保持活跃时间</p>
<blockquote>
<p>keepAliveTime:当线程池中的线程数量大于核心线程数，如果这些多出的线程在经过了keepAliveTime时间后，依然处于空闲状态，那么这些多出的空闲线程将会被结束其生命周期。</p>
</blockquote>
</li>
<li><p>时间单位unit</p>
<blockquote>
<p>keepAliveTime的时间单位</p>
</blockquote>
</li>
<li><p>最大线程池大小 maximumPoolSize</p>
<blockquote>
<p>线程池中所允许创建最大线程数量，除了受JVM内存大小限制外，Linux下还受/proc/sys/kernel/pid_max（即系统允许的最大pid）、/proc/sys/kernel/threads-max（系统支持的最大线程数）、max_user_process（ulimit-u）（每个用户允许的最大进程数）、/proc/sys/vm/max_map_count（Linux支持虚拟内存，也就是交换空间,可以把磁盘的一部分作为RAM的扩展，逻辑存储和物理存储的映射就要保存在地址映射表中。max_map_count限制了线程可以拥有的VMAs ）</p>
</blockquote>
</li>
<li><p>拒绝策略handler</p>
<blockquote>
<p>当线程池中的线程数量达到最大并且阻塞队列也已经满了无法再添加任务时，线程池所采取的处理策略，JDK有四种内建的拒绝策略，下面会讲到。</p>
</blockquote>
</li>
<li><p>等待队列workQueue</p>
<blockquote>
<p>用于存放任务的阻塞队列，当线程池中的核心线程都处在执行任务时，提交的任务将被存储在workQueue进行缓冲。该队列只能存放通过execute方法提交的Runnable任务，如果是个ScheduledThreadPoolExecutor，那么这个队列不仅需要阻塞，而且还是个优先队列。</p>
</blockquote>
</li>
</ul>
<h3 id="核心代码分析"><a href="#核心代码分析" class="headerlink" title="核心代码分析"></a>核心代码分析</h3><p>ThreadPoolExecutor 一个根正苗红的线程池继承类。</p>
<ul>
<li><p>我们看看他的excute方法</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">这里是调用</span><br><span class="line">int corePoolSize = 1;</span><br><span class="line">int maximumPoolSize = 2;</span><br><span class="line">long keepAliveTime = 60;</span><br><span class="line">TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">BlockingQueue&lt;Runnable&gt; workQueue = new LinkedBlockingDeque&lt;&gt;();</span><br><span class="line"></span><br><span class="line">ThreadPoolExecutor threadPoolExecutor = new ThreadPoolExecutor(corePoolSize, maximumPoolSize, keepAliveTime</span><br><span class="line">        , unit, workQueue, Executors.defaultThreadFactory(), new RejectedExecutionHandler() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void rejectedExecution(Runnable r, ThreadPoolExecutor e) &#123;</span><br><span class="line">        throw new RejectedExecutionException(&quot;Task &quot; + r.toString() +</span><br><span class="line">                &quot; rejected from &quot; +</span><br><span class="line">                e.toString());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">threadPoolExecutor.execute(new Runnable() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public void run() &#123;</span><br><span class="line">        System.out.println(&quot;execute!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">=========================</span><br><span class="line"></span><br><span class="line">看看execute的源码</span><br><span class="line">public void execute(Runnable command) &#123;</span><br><span class="line">    if (command == null)</span><br><span class="line">        throw new NullPointerException();</span><br><span class="line">    int c = ctl.get();</span><br><span class="line">    // workerCountOf 从ctl中取工作线程的数量，这里有一定的技巧性，下面详细讲一下</span><br><span class="line">    if (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">        if (addWorker(command, true))</span><br><span class="line">            return;</span><br><span class="line">        c = ctl.get();</span><br><span class="line">    &#125;</span><br><span class="line">    // 看当前线程池状态是否Running，这里也是从ctl取值，有点意思</span><br><span class="line">    // 把任务用offer方法塞进工作队列，如果插入成功，则返回ture</span><br><span class="line">    if (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">        int recheck = ctl.get();</span><br><span class="line">        // 二次检查线程池状态是否为Running，以及从任务队列获取当前任务是否成功</span><br><span class="line">        if (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">            reject(command);</span><br><span class="line">        else if (workerCountOf(recheck) == 0)</span><br><span class="line">            // addWorker方法里通过两个for循环通过ctl判断线程池的当前状态是否能新增线程，通过CAS机制修改线程池状态。最后新建worker对象，插入worker队列。</span><br><span class="line">            addWorker(null, false);</span><br><span class="line">    &#125;</span><br><span class="line">    // 线程池的线程数量不够了，增加线程，增加失败的话就拒绝这次execute调用</span><br><span class="line">    else if (!addWorker(command, false))</span><br><span class="line">        // reject方法里其实是调用定义线程池的时候构造函数传入的handler，JDK内建了四个拒绝策略AbortPolicy、DiscardPolicy、DiscardOldestPolicy、CallerRunsPolicy，含义分别是：抛出RejectedExecutionException异常、直接忽略提交的任务、把之前提交的任务移除，添加新的任务、让当前线程直接处理这个任务。用户也可以实现RejectedExecutionHandler接口，完成自己的拒绝策略。</span><br><span class="line">        reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>DefaultThreadFactory  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">static class DefaultThreadFactory implements ThreadFactory &#123;</span><br><span class="line">    private static final AtomicInteger poolNumber = new AtomicInteger(1);</span><br><span class="line">    private final ThreadGroup group;</span><br><span class="line">    private final AtomicInteger threadNumber = new AtomicInteger(1);</span><br><span class="line">    private final String namePrefix;</span><br><span class="line"></span><br><span class="line">    DefaultThreadFactory() &#123;</span><br><span class="line">        SecurityManager s = System.getSecurityManager();</span><br><span class="line">        group = (s != null) ? s.getThreadGroup() :</span><br><span class="line">                              Thread.currentThread().getThreadGroup();</span><br><span class="line">        namePrefix = &quot;pool-&quot; +</span><br><span class="line">                      poolNumber.getAndIncrement() +</span><br><span class="line">                     &quot;-thread-&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 核心是这个newThread方法</span><br><span class="line">    public Thread newThread(Runnable r) &#123;</span><br><span class="line">        Thread t = new Thread(group, r,</span><br><span class="line">                              namePrefix + threadNumber.getAndIncrement(),</span><br><span class="line">                              0);</span><br><span class="line">        if (t.isDaemon())</span><br><span class="line">            t.setDaemon(false);</span><br><span class="line">        if (t.getPriority() != Thread.NORM_PRIORITY)</span><br><span class="line">            t.setPriority(Thread.NORM_PRIORITY);</span><br><span class="line">        return t;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>ctl是如何存储线程状态和数量的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">定义</span><br><span class="line">private final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));</span><br><span class="line">private static final int COUNT_BITS = Integer.SIZE - 3;</span><br><span class="line">private static final int CAPACITY   = (1 &lt;&lt; COUNT_BITS) - 1;</span><br><span class="line"></span><br><span class="line">// runState is stored in the high-order bits</span><br><span class="line">private static final int RUNNING    = -1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int SHUTDOWN   =  0 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int STOP       =  1 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TIDYING    =  2 &lt;&lt; COUNT_BITS;</span><br><span class="line">private static final int TERMINATED =  3 &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">// Packing and unpacking ctl</span><br><span class="line">private static int runStateOf(int c)     &#123; return c &amp; ~CAPACITY; &#125;</span><br><span class="line">private static int workerCountOf(int c)  &#123; return c &amp; CAPACITY; &#125;</span><br><span class="line">private static int ctlOf(int rs, int wc) &#123; return rs | wc; &#125;</span><br><span class="line"></span><br><span class="line">上面那串定义看了可能有点懵，源码中使用了一个AtomicInteger对将当前线程的工作状态和工作线程数量(有效线程数)使用同一个整数进行包装。</span><br><span class="line">为了将两个数值包装在同一个整数中，它将32位的高3位表示线程的状态值，而后29位来表示线程的数量。</span><br><span class="line">其实这样设计的理由很简单，因为线程的状态和数量往往需要同时更新，然而线程池天生处在一个并发的环境下，那么当对2个变量进行修改时，那么就势必需要通过锁来进行线程安全的处理，从而保证2个变量修改具备原子性；但是这种做法对于性能的影响是非常严重的，因此在ThreadPoolExecutor将两个变量的分别包装在一个变量中，最后的并发操作发生在AtomicInteger上，而AtomicInteger恰恰就是具有一个无锁原子操作类,这样既可以解决线程安全的问题，又可以规避避免所的使用，从而提供性能。</span><br></pre></td></tr></table></figure>
</li>
<li><p>ScheduledThreadPoolExecutor如何实现调度</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">TODO</span><br><span class="line">优先队列</span><br></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="JDK线程池存在的问题"><a href="#JDK线程池存在的问题" class="headerlink" title="JDK线程池存在的问题"></a>JDK线程池存在的问题</h3><ul>
<li>FixedThreadPool 和 SingleThreadPool 允许的请求队列长度为 Integer.MAX_VALUE，可能会堆积大量的请求，从而导致 OOM。</li>
<li>CachedThreadPool 和 ScheduledThreadPool允许的创建线程数量为Integer.MAX_VALUE，可能会创建大量的线程，从而导致 OOM。 </li>
<li>多线程并行处理定时任务时，Timer运行多个TimeTask时，只要其中之一没有捕获抛出的异常，其它任务便会自动终止运行，使用 ScheduledExecutorService 则没有这个问题。</li>
<li>ScheduledExecutorService并发执行大量调度时候有瓶颈，大并发量的线程调度应该用时间环模式。 </li>
</ul>
<p><del>不要感觉自己写几千行的类是很烂的代码，ThreadPoolExecutor也有2100多行（含注释）</del></p>
<h2 id="线程竞争"><a href="#线程竞争" class="headerlink" title="线程竞争"></a>线程竞争</h2><h3 id="线程竞争的定义"><a href="#线程竞争的定义" class="headerlink" title="线程竞争的定义"></a>线程竞争的定义</h3><p>在多线程中，每个线程的执行顺序，是无法预测不可控制的，那么在对数据进行读写的时候便存在由于读写顺序多乱而造成数据混乱错误的可能性。这里涉及到线程锁</p>
<h3 id="用锁控制线程间的竞争"><a href="#用锁控制线程间的竞争" class="headerlink" title="用锁控制线程间的竞争"></a>用锁控制线程间的竞争</h3><blockquote>
<p>这里介绍锁的基本概念以及常见分类，详细在另外的时间再做。</p>
</blockquote>
<ul>
<li>共享锁/排它锁 </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">共享锁和排他锁是从同一时刻是否允许多个线程持有该锁的角度来划分。</span><br><span class="line">共享锁允许同一时刻多个线程进入持有锁，访问临界区资源。而排他锁就是通常意义上的锁，同一时刻只允许一个线程访问临界资源。对于共享锁，主要是指对数据库读操作中的读锁，在读写资源的时候如果没有线程持有写锁和请求写锁，则此时允许多个线程持有读锁。 </span><br><span class="line">在这里理解共享锁的时候，不是任意时刻都允许多线程持有共享锁的，而是在某些特殊情况下才允许多线程持有共享锁，在某些情况下不允许多个线程持有共享锁，否则，如果没有前提条件任意时刻都允许线程任意持有共享锁，则共享锁的存在无意义的。例如读写锁中的读锁，只有当没有写锁和写锁请求的时候，就可以允许多个线程同时持有读锁。这里的前提条件就是“没有写锁和写锁请求”，而不是任意时刻都允许多线程持有共享读锁。</span><br></pre></td></tr></table></figure>
<ul>
<li>悲观锁/乐观锁  </li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">主要用于数据库数据的操作中，而对于线程锁中较为少见。</span><br><span class="line">悲观锁和乐观锁是一种加锁思想。对于乐观锁，在进行数据读取的时候不会加锁，而在进行写入操作的时候会判断一下数据是否被其它线程修改过，如果修改则更新数据，如果没有则继续进行数据写入操作。乐观锁不是系统中自带的锁，而是一种数据读取写入思想。应用场景例如：在向数据库中插入数据的时候，先从数据库中读取记录修改版本标识字段，如果该字段没有发生变化（没有其他线程对数据进行写操作）则执行写入操作，如果发生变化则重新计算数据。</span><br><span class="line">对于悲观锁，无论是进行读操作还是进行写操作都会进行加锁操作。对于悲观锁，如果并发量较大则比较耗费资源，当然保证了数据的安全性。</span><br></pre></td></tr></table></figure>
<ul>
<li>可重入锁/不可重入</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这两个概念是从同一个线程在已经持有锁的前提下能否再次持有锁的角度来区分的。</span><br><span class="line">对于可重入锁，如果该线程已经获取到锁且未释放的情况下允许再次获取该锁访问临界区资源。此种情况主要是用在递归调用的情况下和不同的临界区使用相同的锁的情况下。</span><br><span class="line">对于不可重入锁，则不允许同一线程在持有锁的情况下再次获取该锁并访问临界区资源。对于不可重入锁，使用的时候需要小心以免造成死锁。</span><br></pre></td></tr></table></figure>
<ul>
<li>公平锁/非公平锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这两个概念主要使用线程获取锁的顺序角度来区分的。</span><br><span class="line">对于公平锁，所有等待的线程按照按照请求锁的先后循序分别依次获取锁。</span><br><span class="line">对于非公平锁，等待线程的线程获取锁的顺序和请求的先后不是对应关系。有可能是随机的获取锁，也有可能按照其他策略获取锁，总之不是按照FIFO的顺序获取锁。</span><br><span class="line">在使用ReentrantLock的时候可以通过构造方法主动选择是实现公平锁还是非公平锁。</span><br></pre></td></tr></table></figure>
<ul>
<li>自旋锁/非自旋锁</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这两种概念是从线程等待的处理机制来区分的。</span><br><span class="line">自旋锁在进行锁请求等待的时候不进行wait挂起，不释放CPU资源，执行while空循环。直至获取锁访问临界区资源。适用于等待锁时间较短的情景，如果等待时间较长，则会耗费大量的CPU资源。而如果等待时间较短则可以节约大量的线程切换资源。</span><br><span class="line">非自旋锁在进行锁等待的时候会释放CPU资源，可以通多sleep wait 或者CPU中断切换上下文，切换该线程。在线程等待时间较长的情况下可以选择此种实现机制。</span><br><span class="line">除此之外还有一种介于两者之间的锁机制——自适应自旋锁。当线程进行等待的时候先进性自旋等待，在自旋一定时间(次数)之后如果依旧没有持有锁则挂起等待。在jvm中synchronized锁已经使用该机制进行处理锁等待的情况。</span><br><span class="line">在工作中可以根据不同的情况选取合适的锁进行使用。无论使用哪种锁，其目的都是保证程序能够按照要求顺利执行，避免数据混乱情况的发生。</span><br></pre></td></tr></table></figure>
<p>详细的<a href="https://www.cnblogs.com/PerkinsZhu/p/7392006.html" target="_blank" rel="noopener">参考</a>这里</p>
<h3 id="锁的弊端"><a href="#锁的弊端" class="headerlink" title="锁的弊端"></a>锁的弊端</h3><p>不管是何种锁，本质上都是对资源的访问加以限制，让同一时间只有一个线程访问资源。在高并发的时候，锁往往会成为系统的瓶颈，更不用说同时带来的死锁风险。</p>
<h3 id="不用锁解决线程安全的方式"><a href="#不用锁解决线程安全的方式" class="headerlink" title="不用锁解决线程安全的方式"></a>不用锁解决线程安全的方式</h3><p>我们接下来讨论有无高效解决线程竞争的模式，避免锁带来的以上问题。</p>
<h2 id="常见线程模型"><a href="#常见线程模型" class="headerlink" title="常见线程模型"></a>常见线程模型</h2><h3 id="线程模型的定义"><a href="#线程模型的定义" class="headerlink" title="线程模型的定义"></a>线程模型的定义</h3><p>线程模型决定了应用或框架如何执行代码，所以选择正确的线程模型是很重要的事情。通俗的讲，如果同样给你一定数量的线程如（100个），分析实际的业务场景，如何让它们的效率最大化。这就是选取线程模型应该做的事情。</p>
<blockquote>
<p>同时线程模型也指线程映射到操作系统进程的模型 <a href="https://blog.csdn.net/lyc201219/article/details/79228575" target="_blank" rel="noopener">https://blog.csdn.net/lyc201219/article/details/79228575</a></p>
</blockquote>
<ul>
<li>Future模型</li>
</ul>
<p>结合Callable接口配合使用，Callable是类似于Runnable的接口。Future是把结果放在将来获取，当前主线程并不急于获取处理结果。允许子线程先进行处理一段时间，处理结束之后就把结果保存下来，当主线程需要使用的时候再向子线程索取。如果不使用Future模型，就需要使用到一个全局变量来保存子线程处理之后的结果。子线程处理结束之后，把结果保存在全局变量中供主线程进行调用。一旦涉及到全局能量便存在着多线程读写全局变量错误的风险。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">ExecutorService executorService = Executors.newFixedThreadPool(5);</span><br><span class="line">Future&lt;?&gt; future = executorService.submit(new Callable&lt;Object&gt;() &#123;</span><br><span class="line">    @Override</span><br><span class="line">    public Object call() throws Exception &#123;</span><br><span class="line"></span><br><span class="line">        return null;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line">Object o = future.get();</span><br></pre></td></tr></table></figure>
<ul>
<li>fork&amp;join 模型</li>
</ul>
<p>该模型包含递归思想和回溯思想，递归用来拆分任务，回溯用合并结果。可以用来处理一些可以进行拆分的大任务。其主要是把一个大任务逐级拆分为多个子任务，然后分别在子线程中执行，当每个子线程执行结束之后逐级回溯，返回结果进行汇总合并，最终得出想要的结果</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 将num*2 用frok&amp;join的思想做</span><br><span class="line"> */</span><br><span class="line">static class ResultTask extends RecursiveTask&lt;Integer&gt; &#123;</span><br><span class="line">    private int num;</span><br><span class="line"></span><br><span class="line">    public ResultTask(int num) &#123;</span><br><span class="line">        this.num = num;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Override</span><br><span class="line">    protected Integer compute() &#123;</span><br><span class="line">        if (num &lt; 10) &#123;</span><br><span class="line">            return num * 2;</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            //对任务进行拆分，注意这里不仅仅可以一分为二进行拆分，也可以拆为多个子任务</span><br><span class="line">            int temp = num / 2;</span><br><span class="line">            ResultTask left = new ResultTask(temp);</span><br><span class="line">            ResultTask right = new ResultTask(num - temp);</span><br><span class="line">            left.fork();</span><br><span class="line">            right.fork();</span><br><span class="line">            //对子任务处理的结果进行合并</span><br><span class="line">            int result = left.join() + right.join();</span><br><span class="line">            return result;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public static void main(String[] args) throws Exception &#123;</span><br><span class="line">    ForkJoinPool pool = new ForkJoinPool();</span><br><span class="line">    ForkJoinTask&lt;Integer&gt; future = pool.submit(new ResultTask(100));</span><br><span class="line">    try &#123;</span><br><span class="line">        Integer integer = future.get();</span><br><span class="line">        System.out.println(integer);</span><br><span class="line">        pool.awaitTermination(1000, TimeUnit.MILLISECONDS);</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    pool.shutdown();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>生产者消费者模型</li>
</ul>
<p>生产者消费者模型都比较熟悉，其核心是使用一个缓存来保存任务。开启一个/多个线程来生产任务，然后再开启一个/多个来从缓存中取出任务进行处理。这样的好处是任务的生成和处理分隔开，生产者不需要处理任务，只负责向生成任务然后保存到缓存。而消费者只需要从缓存中取出任务进行处理。使用的时候可以根据任务的生成情况和处理情况开启不同的线程来处理。比如，生成的任务速度较快，那么就可以灵活的多开启几个消费者线程进行处理，这样就可以避免任务的处理响应缓慢的问题</p>
<ul>
<li>master-worker模型</li>
</ul>
<p>master-worker模型类似于任务分发策略，开启一个master线程接收任务，然后在master中根据任务的具体情况进行分发给其它worker子线程，然后由子线程处理任务。如需返回结果，则worker处理结束之后把处理结果返回给master</p>
<ul>
<li>actor消息模型</li>
</ul>
<p>actor模型属于一种基于消息传递机制并行任务处理思想，它以消息的形式来进行线程间数据传输，避免了全局变量的使用，进而避免了数据同步错误的隐患。actor在接受到消息之后可以自己进行处理，也可以继续传递（分发）给其它actor进行处理。Actors一大重要特征在于actors之间相互隔离，它们并不互相共享内存。这点区别于上述的对象。也就是说，一个actor能维持一个私有的状态，并且这个状态不可能被另一个actor所改变。</p>
<p>actor并发模型的应用场景？<br>适合有状态或者称可变状态的业务场景，如果用DDD术语，适合聚合根，具体案例如订单，订单有状态，比如未付款未发货，已经付款未发货，已付款已发货，导致订单状态的变化是事件行为，比如付款行为导致顶大状态切换到”已经付款未发货”。</p>
<p>actor的原理<br>行为导致状态变化，行为执行是依靠线程，比如用户发出一个付款的请求，服务器后端派出一个线程来执行付款请求，携带付款的金额和银行卡等等信息，当付款请求被成功完成后，线程还要做的事情就是改变订单状态，这时线程访问订单的一个方法比如changeState。如果后台有管理员同时修改这个订单状态，那么实际有两个线程共同访问同一个数据，这时就必须锁，比如我们在changeState方法前加上sychronized这样同步语法。使用同步语法坏处是每次只能一个线程进行处理，如同上厕所，只有一个蹲坑，人多就必须排队，这种情况性能很低。</p>
<p>避免changeState方法被外部两个线程同时占用访问，那么我们自己设计专门的线程守护订单状态，而不是普通方法代码，普通方法代码比较弱势，容易被外部线程hold住，而我们设计的这个对象没有普通方法，只有线程，这样就变成Order的守护线程和外部访问请求线程的通讯问题了。Actor采取的这种类似消息机制的方式，实际在守护线程和外部线程之间有一个队列，俗称信箱，外部线程只要把请求放入，守护线程就读取进行处理。这种异步高效方式是Actor基本原理，以ERlang和Scala语言为主要特征，他们封装得更好，类似将消息队列微观化了。<br>参考<a href="http://www.infoq.com/cn/articles/Building-Reactive-Applications-with-Akka" target="_blank" rel="noopener">使用Akka Actor和Java 8构建反应式应用</a></p>
<ul>
<li>reactor模型</li>
</ul>
<p>一图胜千言，来看看Doug Lea大神画的图（Scalable IO in Java）<br><img src="https://images2018.cnblogs.com/blog/1424165/201808/1424165-20180803142242491-1328318201.png" alt="image"></p>
<h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ul>
<li><a href="https://www.jianshu.com/p/20b7327f9f56" target="_blank" rel="noopener">https://www.jianshu.com/p/20b7327f9f56</a> ThreadPoolExecutor源码分析</li>
<li><a href="https://blog.csdn.net/wangjinnan16/article/details/78377642" target="_blank" rel="noopener">https://blog.csdn.net/wangjinnan16/article/details/78377642</a>  Netty4实战第十五章：选择正确的线程模型</li>
<li><a href="https://www.cnblogs.com/PerkinsZhu/p/7570775.html" target="_blank" rel="noopener">https://www.cnblogs.com/PerkinsZhu/p/7570775.html</a> 常见线程模型介绍</li>
<li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf" target="_blank" rel="noopener">http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf</a> Scalable IO in Java</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>投食入口</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>打赏</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/images/reward/wechatpay_reward.jpg" alt="xlbpowder 微信支付"/>
        <p>微信支付</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/images/reward/alipay_reward.jpg" alt="xlbpowder 支付宝"/>
        <p>支付宝</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/Java/" rel="tag"># Java</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2018/09/04/hexo/" rel="next" title="hexo">
                <i class="fa fa-chevron-left"></i> hexo
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2018/11/19/Stream/" rel="prev" title="Stream">
                Stream <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  
     <div id="gitalk-container"></div>
  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/new_favicon_source_02_180x180.jpg"
                alt="xlbpowder" />
            
              <p class="site-author-name" itemprop="name">xlbpowder</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/xlbpowder" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/u/1870931111?refer_flag=1001030201_" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-weibo"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://xlbpowder.cn/image/QRcode/wechat_qrcode.jpg" target="_blank" title="WeChat">
                      
                        <i class="fa fa-fw fa-weixin"></i>WeChat</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#线程模型分享-（上）"><span class="nav-number">1.</span> <span class="nav-text">线程模型分享 （上）</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#引言"><span class="nav-number">1.1.</span> <span class="nav-text">引言</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程启动与停止"><span class="nav-number">1.2.</span> <span class="nav-text">线程启动与停止</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#JDK线程池继承层次"><span class="nav-number">1.3.</span> <span class="nav-text">JDK线程池继承层次</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#结构图"><span class="nav-number">1.3.1.</span> <span class="nav-text">结构图</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#线程池核心要素"><span class="nav-number">1.3.2.</span> <span class="nav-text">线程池核心要素</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#核心代码分析"><span class="nav-number">1.3.3.</span> <span class="nav-text">核心代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#JDK线程池存在的问题"><span class="nav-number">1.3.4.</span> <span class="nav-text">JDK线程池存在的问题</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#线程竞争"><span class="nav-number">1.4.</span> <span class="nav-text">线程竞争</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程竞争的定义"><span class="nav-number">1.4.1.</span> <span class="nav-text">线程竞争的定义</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#用锁控制线程间的竞争"><span class="nav-number">1.4.2.</span> <span class="nav-text">用锁控制线程间的竞争</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#锁的弊端"><span class="nav-number">1.4.3.</span> <span class="nav-text">锁的弊端</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#不用锁解决线程安全的方式"><span class="nav-number">1.4.4.</span> <span class="nav-text">不用锁解决线程安全的方式</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#常见线程模型"><span class="nav-number">1.5.</span> <span class="nav-text">常见线程模型</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#线程模型的定义"><span class="nav-number">1.5.1.</span> <span class="nav-text">线程模型的定义</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#参考资料"><span class="nav-number">1.6.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2018 &mdash; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-snowflake-o"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">xlbpowder</span>

  

  <!-- 站长统计 -->
  
   <span style="display: none"
    <script src="http://s6.cnzz.com/stat.php?id=1277962807&web_id=1277962807" type="text/javascript"></script>
   </span>
  

  <!-- 不蒜子统计 
  
  -->
</div>









        
<div class="busuanzi-count">
  <script async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>

  
    <span class="site-uv">
      访客数
      <span class="busuanzi-value" id="busuanzi_value_site_uv"></span>
      人
    </span>
  

  
    <span class="site-pv">
      总访问量
      <span class="busuanzi-value" id="busuanzi_value_site_pv"></span>
      次
    </span>
  
</div>








  <div style="display: none;">
    <script src="//s95.cnzz.com/z_stat.php?id=1277962807&web_id=1277962807" language="JavaScript"></script>
  </div>



        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  

  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  <link rel="stylesheet" href="/lib/gitalk/gitalk.css">
  <script src="/lib/gitalk/gitalk.min.js"></script>
   <script type="text/javascript">
		var gitalk = new Gitalk({
		  clientID: 'cb903b000756e9d9d1c7',
		  clientSecret: 'ae8bc7faa89639391f0961c05fed416f38e8d820',
		  repo: 'xlbpowder.comments',
		  owner: 'xlbpowder',
		  admin: ['xlbpowder'], 
		  id: location.pathname,
		  distractionFreeMode: ''
		})
		gitalk.render('gitalk-container')           
       </script>

  





  

  

  

  
  

  

  

  

<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"debug":false,"model":{"jsonPath":"/live2dw/assets/koharu.model.json"},"mobile":{"show":true,"scale":0.5},"log":false});</script></body>
</html>
